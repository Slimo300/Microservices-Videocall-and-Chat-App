// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

package mock

import (
	context "context"
	multipart "mime/multipart"

	mock "github.com/stretchr/testify/mock"

	storage "github.com/Slimo300/Microservices-Videocall-and-Chat-App/backend/lib/storage"
)

// MockStorage is an autogenerated mock type for the Storage type
type MockStorage struct {
	mock.Mock
}

// DeleteFile provides a mock function with given fields: ctx, key
func (_m *MockStorage) DeleteFile(ctx context.Context, key string) error {
	ret := _m.Called(ctx, key)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteFilesByPrefix provides a mock function with given fields: ctx, prefix
func (_m *MockStorage) DeleteFilesByPrefix(ctx context.Context, prefix string) error {
	ret := _m.Called(ctx, prefix)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, prefix)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetPresignedGetRequests provides a mock function with given fields: ctx, files
func (_m *MockStorage) GetPresignedGetRequests(ctx context.Context, files ...storage.PresignGetFileInput) ([]storage.PresignGetFileOutput, error) {
	_va := make([]interface{}, len(files))
	for _i := range files {
		_va[_i] = files[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []storage.PresignGetFileOutput
	if rf, ok := ret.Get(0).(func(context.Context, ...storage.PresignGetFileInput) []storage.PresignGetFileOutput); ok {
		r0 = rf(ctx, files...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]storage.PresignGetFileOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, ...storage.PresignGetFileInput) error); ok {
		r1 = rf(ctx, files...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPresignedPutRequests provides a mock function with given fields: ctx, files
func (_m *MockStorage) GetPresignedPutRequests(ctx context.Context, files ...storage.PresignPutFileInput) ([]storage.PresignPutFileOutput, error) {
	_va := make([]interface{}, len(files))
	for _i := range files {
		_va[_i] = files[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []storage.PresignPutFileOutput
	if rf, ok := ret.Get(0).(func(context.Context, ...storage.PresignPutFileInput) []storage.PresignPutFileOutput); ok {
		r0 = rf(ctx, files...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]storage.PresignPutFileOutput)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, ...storage.PresignPutFileInput) error); ok {
		r1 = rf(ctx, files...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UploadFile provides a mock function with given fields: ctx, key, file, acl
func (_m *MockStorage) UploadFile(ctx context.Context, key string, file multipart.File, acl storage.ACL) error {
	ret := _m.Called(ctx, key, file, acl)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, multipart.File, storage.ACL) error); ok {
		r0 = rf(ctx, key, file, acl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewMockStorage interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockStorage creates a new instance of MockStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockStorage(t mockConstructorTestingTNewMockStorage) *MockStorage {
	mock := &MockStorage{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
